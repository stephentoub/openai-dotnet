// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Text.Json;
using OpenAI;

namespace OpenAI.Realtime
{
    [PersistableModelProxy(typeof(InternalUnknownRealtimeServerEventGA))]
    public partial class RealtimeServerUpdate : IJsonModel<RealtimeServerUpdate>
    {
        internal RealtimeServerUpdate()
        {
        }

        void IJsonModel<RealtimeServerUpdate>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
#pragma warning disable SCME0001 // Type is for evaluation purposes only and is subject to change or removal in future updates.
            if (Patch.Contains("$"u8))
            {
                writer.WriteRawValue(Patch.GetJson("$"u8));
                return;
            }
#pragma warning restore SCME0001 // Type is for evaluation purposes only and is subject to change or removal in future updates.

            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        protected virtual void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            string format = options.Format == "W" ? ((IPersistableModel<RealtimeServerUpdate>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(RealtimeServerUpdate)} does not support writing '{format}' format.");
            }
#pragma warning disable SCME0001 // Type is for evaluation purposes only and is subject to change or removal in future updates.
            if (!Patch.Contains("$.type"u8))
            {
                writer.WritePropertyName("type"u8);
                writer.WriteStringValue(Kind.ToString());
            }
#pragma warning restore SCME0001 // Type is for evaluation purposes only and is subject to change or removal in future updates.
        }

        RealtimeServerUpdate IJsonModel<RealtimeServerUpdate>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options) => JsonModelCreateCore(ref reader, options);

        protected virtual RealtimeServerUpdate JsonModelCreateCore(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            string format = options.Format == "W" ? ((IPersistableModel<RealtimeServerUpdate>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(RealtimeServerUpdate)} does not support reading '{format}' format.");
            }
            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeRealtimeServerUpdate(document.RootElement, null, options);
        }

        internal static RealtimeServerUpdate DeserializeRealtimeServerUpdate(JsonElement element, BinaryData data, ModelReaderWriterOptions options)
        {
            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            if (element.TryGetProperty("type"u8, out JsonElement discriminator))
            {
                switch (discriminator.GetString())
                {
                    case "error":
                        return RealtimeServerUpdateError.DeserializeRealtimeServerUpdateError(element, data, options);
                    case "session.created":
                        return RealtimeServerUpdateSessionCreated.DeserializeRealtimeServerUpdateSessionCreated(element, data, options);
                    case "session.updated":
                        return RealtimeServerUpdateSessionUpdated.DeserializeRealtimeServerUpdateSessionUpdated(element, data, options);
                    case "conversation.item.added":
                        return RealtimeServerUpdateConversationItemAdded.DeserializeRealtimeServerUpdateConversationItemAdded(element, data, options);
                    case "conversation.item.done":
                        return RealtimeServerUpdateConversationItemDone.DeserializeRealtimeServerUpdateConversationItemDone(element, data, options);
                    case "conversation.item.retrieved":
                        return RealtimeServerUpdateConversationItemRetrieved.DeserializeRealtimeServerUpdateConversationItemRetrieved(element, data, options);
                    case "conversation.item.input_audio_transcription.completed":
                        return RealtimeServerUpdateConversationItemInputAudioTranscriptionCompleted.DeserializeRealtimeServerUpdateConversationItemInputAudioTranscriptionCompleted(element, data, options);
                    case "conversation.item.input_audio_transcription.delta":
                        return RealtimeServerUpdateConversationItemInputAudioTranscriptionDelta.DeserializeRealtimeServerUpdateConversationItemInputAudioTranscriptionDelta(element, data, options);
                    case "conversation.item.input_audio_transcription.segment":
                        return RealtimeServerUpdateConversationItemInputAudioTranscriptionSegment.DeserializeRealtimeServerUpdateConversationItemInputAudioTranscriptionSegment(element, data, options);
                    case "conversation.item.input_audio_transcription.failed":
                        return RealtimeServerUpdateConversationItemInputAudioTranscriptionFailed.DeserializeRealtimeServerUpdateConversationItemInputAudioTranscriptionFailed(element, data, options);
                    case "conversation.item.truncated":
                        return RealtimeServerUpdateConversationItemTruncated.DeserializeRealtimeServerUpdateConversationItemTruncated(element, data, options);
                    case "conversation.item.deleted":
                        return RealtimeServerUpdateConversationItemDeleted.DeserializeRealtimeServerUpdateConversationItemDeleted(element, data, options);
                    case "input_audio_buffer.committed":
                        return RealtimeServerUpdateInputAudioBufferCommitted.DeserializeRealtimeServerUpdateInputAudioBufferCommitted(element, data, options);
                    case "input_audio_buffer.dtmf_event_received":
                        return RealtimeServerUpdateInputAudioBufferDtmfEventReceived.DeserializeRealtimeServerUpdateInputAudioBufferDtmfEventReceived(element, data, options);
                    case "input_audio_buffer.cleared":
                        return RealtimeServerUpdateInputAudioBufferCleared.DeserializeRealtimeServerUpdateInputAudioBufferCleared(element, data, options);
                    case "input_audio_buffer.speech_started":
                        return RealtimeServerUpdateInputAudioBufferSpeechStarted.DeserializeRealtimeServerUpdateInputAudioBufferSpeechStarted(element, data, options);
                    case "input_audio_buffer.speech_stopped":
                        return RealtimeServerUpdateInputAudioBufferSpeechStopped.DeserializeRealtimeServerUpdateInputAudioBufferSpeechStopped(element, data, options);
                    case "input_audio_buffer.timeout_triggered":
                        return RealtimeServerUpdateInputAudioBufferTimeoutTriggered.DeserializeRealtimeServerUpdateInputAudioBufferTimeoutTriggered(element, data, options);
                    case "response.created":
                        return RealtimeServerUpdateResponseCreated.DeserializeRealtimeServerUpdateResponseCreated(element, data, options);
                    case "response.done":
                        return RealtimeServerUpdateResponseDone.DeserializeRealtimeServerUpdateResponseDone(element, data, options);
                    case "response.output_item.added":
                        return RealtimeServerUpdateResponseOutputItemAdded.DeserializeRealtimeServerUpdateResponseOutputItemAdded(element, data, options);
                    case "response.output_item.done":
                        return RealtimeServerUpdateResponseOutputItemDone.DeserializeRealtimeServerUpdateResponseOutputItemDone(element, data, options);
                    case "response.content_part.added":
                        return RealtimeServerUpdateResponseContentPartAdded.DeserializeRealtimeServerUpdateResponseContentPartAdded(element, data, options);
                    case "response.content_part.done":
                        return RealtimeServerUpdateResponseContentPartDone.DeserializeRealtimeServerUpdateResponseContentPartDone(element, data, options);
                    case "response.output_text.delta":
                        return RealtimeServerUpdateResponseOutputTextDelta.DeserializeRealtimeServerUpdateResponseOutputTextDelta(element, data, options);
                    case "response.output_text.done":
                        return RealtimeServerUpdateResponseOutputTextDone.DeserializeRealtimeServerUpdateResponseOutputTextDone(element, data, options);
                    case "response.output_audio_transcript.delta":
                        return RealtimeServerUpdateResponseOutputAudioTranscriptDelta.DeserializeRealtimeServerUpdateResponseOutputAudioTranscriptDelta(element, data, options);
                    case "response.output_audio_transcript.done":
                        return RealtimeServerUpdateResponseOutputAudioTranscriptDone.DeserializeRealtimeServerUpdateResponseOutputAudioTranscriptDone(element, data, options);
                    case "response.output_audio.delta":
                        return RealtimeServerUpdateResponseOutputAudioDelta.DeserializeRealtimeServerUpdateResponseOutputAudioDelta(element, data, options);
                    case "response.output_audio.done":
                        return RealtimeServerUpdateResponseOutputAudioDone.DeserializeRealtimeServerUpdateResponseOutputAudioDone(element, data, options);
                    case "response.function_call_arguments.delta":
                        return RealtimeServerUpdateResponseFunctionCallArgumentsDelta.DeserializeRealtimeServerUpdateResponseFunctionCallArgumentsDelta(element, data, options);
                    case "response.function_call_arguments.done":
                        return RealtimeServerUpdateResponseFunctionCallArgumentsDone.DeserializeRealtimeServerUpdateResponseFunctionCallArgumentsDone(element, data, options);
                    case "response.mcp_call_arguments.delta":
                        return RealtimeServerUpdateResponseMcpCallArgumentsDelta.DeserializeRealtimeServerUpdateResponseMcpCallArgumentsDelta(element, data, options);
                    case "response.mcp_call_arguments.done":
                        return RealtimeServerUpdateResponseMcpCallArgumentsDone.DeserializeRealtimeServerUpdateResponseMcpCallArgumentsDone(element, data, options);
                    case "response.mcp_call.in_progress":
                        return RealtimeServerUpdateResponseMcpCallInProgress.DeserializeRealtimeServerUpdateResponseMcpCallInProgress(element, data, options);
                    case "response.mcp_call.completed":
                        return RealtimeServerUpdateResponseMcpCallCompleted.DeserializeRealtimeServerUpdateResponseMcpCallCompleted(element, data, options);
                    case "response.mcp_call.failed":
                        return RealtimeServerUpdateResponseMcpCallFailed.DeserializeRealtimeServerUpdateResponseMcpCallFailed(element, data, options);
                    case "mcp_list_tools.in_progress":
                        return RealtimeServerUpdateMcpListToolsInProgress.DeserializeRealtimeServerUpdateMcpListToolsInProgress(element, data, options);
                    case "mcp_list_tools.completed":
                        return RealtimeServerUpdateMcpListToolsCompleted.DeserializeRealtimeServerUpdateMcpListToolsCompleted(element, data, options);
                    case "mcp_list_tools.failed":
                        return RealtimeServerUpdateMcpListToolsFailed.DeserializeRealtimeServerUpdateMcpListToolsFailed(element, data, options);
                    case "rate_limits.updated":
                        return RealtimeServerUpdateRateLimitsUpdated.DeserializeRealtimeServerUpdateRateLimitsUpdated(element, data, options);
                    case "conversation.item.created":
                        return RealtimeServerUpdateConversationItemCreated.DeserializeRealtimeServerUpdateConversationItemCreated(element, data, options);
                    case "conversation.created":
                        return RealtimeServerUpdateConversationCreated.DeserializeRealtimeServerUpdateConversationCreated(element, data, options);
                    case "output_audio_buffer.started":
                        return RealtimeServerUpdateOutputAudioBufferStarted.DeserializeRealtimeServerUpdateOutputAudioBufferStarted(element, data, options);
                    case "output_audio_buffer.stopped":
                        return RealtimeServerUpdateOutputAudioBufferStopped.DeserializeRealtimeServerUpdateOutputAudioBufferStopped(element, data, options);
                    case "output_audio_buffer.cleared":
                        return RealtimeServerUpdateOutputAudioBufferCleared.DeserializeRealtimeServerUpdateOutputAudioBufferCleared(element, data, options);
                }
            }
            return InternalUnknownRealtimeServerEventGA.DeserializeInternalUnknownRealtimeServerEventGA(element, data, options);
        }

        BinaryData IPersistableModel<RealtimeServerUpdate>.Write(ModelReaderWriterOptions options) => PersistableModelWriteCore(options);

        protected virtual BinaryData PersistableModelWriteCore(ModelReaderWriterOptions options)
        {
            string format = options.Format == "W" ? ((IPersistableModel<RealtimeServerUpdate>)this).GetFormatFromOptions(options) : options.Format;
            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, OpenAIContext.Default);
                default:
                    throw new FormatException($"The model {nameof(RealtimeServerUpdate)} does not support writing '{options.Format}' format.");
            }
        }

        RealtimeServerUpdate IPersistableModel<RealtimeServerUpdate>.Create(BinaryData data, ModelReaderWriterOptions options) => PersistableModelCreateCore(data, options);

        protected virtual RealtimeServerUpdate PersistableModelCreateCore(BinaryData data, ModelReaderWriterOptions options)
        {
            string format = options.Format == "W" ? ((IPersistableModel<RealtimeServerUpdate>)this).GetFormatFromOptions(options) : options.Format;
            switch (format)
            {
                case "J":
                    using (JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions))
                    {
                        return DeserializeRealtimeServerUpdate(document.RootElement, data, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(RealtimeServerUpdate)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<RealtimeServerUpdate>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}
